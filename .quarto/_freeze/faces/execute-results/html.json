{
  "hash": "3f3e9e16daf5652f2757cfa4b128c80c",
  "result": {
    "markdown": "---\ntitle: \"Eigenfaces in R\"\n---\n\n\n# 3 PCA and Eigenface\n\n## Initial setup and utility functions\n\n::: {.cell}\n\n```{.r .cell-code}\n# Spatial data rasterization package\nremotes::install_github(\"rspatial/terra\", configure.args = \"--with-proj-lib=$(brew --prefix)/lib/\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nSkipping install of 'terra' from a github remote, the SHA1 (b7757c30) has not changed since last install.\n  Use `force = TRUE` to force installation\n```\n:::\n\n```{.r .cell-code}\nlibrary(\"terra\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nterra 1.7.24\n```\n:::\n\n```{.r .cell-code}\n# Raw \"faces.dat\" data as dataframe. Each row is one face, and the 4096 columns\n# each represent a pixel value in the face, in a 64 x 64 image.\nfacedata_raw <- read.delim(file = \"data/faces.dat\", header = FALSE, sep = \"\")\n\n# Creates an image of a face given it's 4096 pixel values\ncreate_face <- function(values) {\n    # New SpatRaster object with correct face parameters\n    face_rast <- rast(nrows = 64, ncols = 64)\n    # Set extent\n    ext(face_rast) <- c(0, 64, 0, 64)\n    # Set pixel values\n    values(face_rast) <- values\n    # Return face rotated to upright orientation\n    return(trans(face_rast))\n}\n\n# Displays a face in grayscale colour\nshow_face_grayscale <- function(rast) {\n    par(xaxt = \"n\", yaxt = \"n\")\n    cols <- gray(seq(0, 1, length = 256))\n    image(rast, col = cols)\n}\n\n# Displays a face using a divergent colour scale\nshow_face_divergent <- function(rast) {\n    par(xaxt = \"n\", yaxt = \"n\")\n    plot(rast)\n}\n```\n:::\n\n\\newpage\n\n## (a)\n\n::: {.cell}\n\n```{.r .cell-code}\n# Vector of pixel values of 100th face\nvector_100 <- t(facedata_raw[100, ])\n\n# Rasterize and show face\nface_raw_100 <- create_face(vector_100)\nshow_face_grayscale(face_raw_100)\ntitle(\"100th Face\")\n```\n\n::: {.cell-output-display}\n![](faces_files/figure-html/a-1.png){width=672}\n:::\n:::\n\n\\newpage\n\n## (b)\n\n::: {.cell}\n\n```{.r .cell-code}\n# The mean vector of face pixel values\nvector_mean <- as.matrix(colMeans(facedata_raw))\n# Rasterize and show mean face\nface_mean <- create_face(vector_mean)\nshow_face_grayscale(face_mean)\ntitle(\"Mean Face\")\n```\n\n::: {.cell-output-display}\n![](faces_files/figure-html/b-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# Face data with the mean face vector removed\nfaces_removed <- facedata_raw\n# Remove mean vector from each face\nfor (i in seq_len(nrow(faces_removed))) {\n    face <- faces_removed[i, ]\n    face_new <- face - t(vector_mean)\n    faces_removed[i, ] <- face_new\n}\n\n# Vector of pixel values of 100th face, with the mean removed\nvector_removed_100 <- t(faces_removed[100, ])\n\n# Rasterize and show face\nface_removed_100 <- create_face(vector_removed_100)\npar(mfrow = c(1, 2))\nshow_face_grayscale(face_removed_100)\nshow_face_divergent(face_removed_100)\n```\n\n::: {.cell-output-display}\n![](faces_files/figure-html/b-2.png){width=672}\n:::\n:::\n\nThe 100th face with the mean face values subtracted, rasterized. On the left is a grayscale image; on the right is colourized using a divergent colour scale to better visualize negative values.\n\\newpage\n\n## (c)\n\n::: {.cell}\n\n```{.r .cell-code}\n# Principal component analysis of faces with mean removed\npca <- prcomp(faces_removed, center = FALSE)\n\n# Principal components from PCA\npcs <- pca$x\n# Eigenvectors from PCA\nevecs <- pca$rotation\n# Eigenvalues from PCA\nevals <- pca$sdev^2\n# Proportion of variance from PCA\npv <- evals / sum(evals)\n# Cumulative proportion of variance from PCA\npv_cum <- cumsum(evals) / sum(evals)\n\n# Plot scree plots of Eigenvalues\nplot(\n    pv * 100,\n    type = \"b\",\n    ylim = c(0, 25),\n    xlab = \"Eigenvalues\",\n    ylab = \"Proportion of variance (percentage)\",\n    main = \"Proportion explained by Eigenvalues\"\n)\n```\n\n::: {.cell-output-display}\n![](faces_files/figure-html/c-1.png){width=672}\n:::\n\n```{.r .cell-code}\nplot(\n    pv_cum * 100,\n    type = \"b\",\n    ylim = c(0, 100),\n    xlab = \"Eigenvalues\",\n    ylab = \"Cumulative Proportion of variance (percentage)\",\n    main = \"Cumulative Proportion of variance explained by Eigenvalues\"\n)\n```\n\n::: {.cell-output-display}\n![](faces_files/figure-html/c-2.png){width=672}\n:::\n:::\n\nEigenvalues plotted against proportion of variance explained. The first plot shows individual Eigenvalue variance percentages sorted in descending order, whilst the second plot shows the cumulative proportion for each descending Eigenvalue.\n\\newpage\n\n## (d)\n\n::: {.cell}\n\n```{.r .cell-code}\n# Last (400th) Eigenvalue\neval_400 <- evals[400]\neval_400\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.797793e-25\n```\n:::\n:::\n\nThe 400th Eigenvalue shown above is equal to zero (shown as a very small number due to the limitations of \"numerics\" in R, essentially equivalent to zero). This can be expected because Eigenvalues represent the variance in the values based on each principal component (PC). Since they are sorted in descending order, we can see that the first few PCs, especially the first one, contribute a very large amount to the variance of the face data. Conversely, the Eigenvalues drop off rapidly until our final Eigenvalue of zero. An Eigenvalue of zero means that the PC associated with it does not contribute to the variance of the data much at all, and the first 399 values have already captured the variability.\n\\newpage\n\n## (e)\n\n::: {.cell}\n\n```{.r .cell-code}\n# Threshold to keep Eigenvalues explaining at least this amount of variance\nthreshold <- 0.95\n\n# Show cumulative variance with threshold marked\npar(mfrow = c(1, 1))\nplot(\n    pv_cum * 100,\n    type = \"b\",\n    ylim = c(0, 100),\n    xlab = \"Eigenvalues\",\n    ylab = \"Cumulative Proportion of variance (percentage)\",\n    main = \"A: Threshold of 0.95 visualized\"\n)\nabline(h = 95, lty = \"dashed\", col = \"red\")\n```\n\n::: {.cell-output-display}\n![](faces_files/figure-html/e-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# Number of Eigenvalues/PCs to keep based on threshold\nkeep <- min(which(pv_cum > threshold))\nkeep\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 123\n```\n:::\n\n```{.r .cell-code}\n# Show cumulative variance with threshold marked, with cropped x-axis\nplot(\n    pv_cum * 100,\n    type = \"b\",\n    ylim = c(0, 100),\n    xlim = c(0, 140),\n    xlab = \"Eigenvalues (cropped)\",\n    ylab = \"Cumulative Proportion of variance (percentage)\",\n    main = \"B: Threshold of 0.95 visualized for first 140 Eigenvalues\"\n)\nabline(h = 95, lty = \"dashed\", col = \"red\")\n```\n\n::: {.cell-output-display}\n![](faces_files/figure-html/e-2.png){width=672}\n:::\n:::\n\nTo account for most of the variance, a threshold can be set to determine the number of prinicpal components (PCs) that account for this proportion of variance. For example, with a threshold of 50%, or 0.50, you would determine at which number of PCs the cumulative proportion of variance explained reaches 50% of the total.\n\nI set the variance at 0.95, and determined the number of Eigenvalues to keep based on it. The first plot (A) shows the cumulative proportion of variance associated with each Eigenvalue, and we can see a red dashed line visualizing the cumulative variance proportion of 0.95. After determining the intersect of the scree plot and the threshold, I zoomed into the plot to better see individual points on the cumulative scree plot. 95% of the variance is explained by the first 123 PCs, which already removes 277 less necessary PCs. This way, we can still account for most of the variance at 95%, whilst cutting the number of PCs down to under a third of the size.\n\\newpage\n\n## (f)\n\n::: {.cell}\n\n```{.r .cell-code}\n# Defines how many top Eigenvectors to take (i.e. the top n values)\nn_top <- 5\n\n# The top 5 Eigenvectors (PCs)\nevecs_topn <- evecs[, 1:n_top]\n\n# Iterate and show top n Eigenvectors\nfor (i in seq_len(n_top)) {\n    # Current Eigenvector\n    evec <- evecs_topn[, i]\n    # Rasterize and show the Eigenvector visualization\n    par(mfrow = c(1, 2))\n    face_evec <- create_face(evec)\n    show_face_grayscale(face_evec)\n    title(paste0(\"Eigenvector \", i))\n    show_face_divergent(face_evec)\n}\n```\n\n::: {.cell-output-display}\n![](faces_files/figure-html/f-1.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](faces_files/figure-html/f-2.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](faces_files/figure-html/f-3.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](faces_files/figure-html/f-4.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](faces_files/figure-html/f-5.png){width=672}\n:::\n:::\n\nSince the Eigenvector values are relative and not in standard 8-bit colour format, they are visualized above as both grayscale and colourized using diverging colour scales. \n\\newpage\n\n## (g)\n\n::: {.cell}\n\n```{.r .cell-code}\n# List of number of principal components to use in reconstructions\nn_pcs <- c(10, 100, 200, 399)\n\n# nth face to be reconstructed\nn_face <- 100\n\n# Rasterize mean face, raw face, and face with mean removed for reference\npar(mfrow = c(1, 3))\nshow_face_grayscale(face_mean)\ntitle(\"Mean Face\")\nvector_raw_n <- t(facedata_raw[n_face, ])\nface_raw_n <- create_face(vector_raw_n)\nshow_face_grayscale(face_raw_n)\ntitle(\"Raw Face Image\")\n# Face vector of 4096 pixel values with the mean removed for reconstruction\nvector_removed_n <- t(faces_removed[n_face, ])\nface_removed_n <- create_face(vector_removed_n)\nshow_face_grayscale(face_removed_n)\ntitle(\"Mean Removed\")\n```\n\n::: {.cell-output-display}\n![](faces_files/figure-html/g-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# Iterate and reconstruct specifed face with specifed PCs\npar(mfrow = c(1, length(n_pcs) / 2))\nfor (n in seq_len(length(n_pcs))) {\n    # The top n selected principal components\n    evecs_selected <- as.matrix(evecs[, 1:n_pcs[n]])\n    # Projection of face with mean subtracted onto selected Eigenvectors\n    proj <- t(vector_removed_n) %*% evecs_selected\n    # Reconstructed vector from projection and Eigenvectors with mean added back\n    vector_reconstr <- t(proj %*% t(evecs_selected)) + vector_mean\n\n    # Rasterize and show reconstructed face\n    face_reconstr <- create_face(vector_reconstr)\n    show_face_grayscale(face_reconstr)\n    title(paste0(n_pcs[n], \" PCs\"))\n}\n```\n\n::: {.cell-output-display}\n![](faces_files/figure-html/g-2.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](faces_files/figure-html/g-3.png){width=672}\n:::\n:::\n\nWe can see clearly that the more principal components used in the reconstruction, the better the reconstruction is, and the closer it is to the original raw face. With only the top 10 principal components, the face reconstruction looks very similar to the mean. With 399 principal components, the reconstruction is virtually identical to the raw.\n",
    "supporting": [
      "faces_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}